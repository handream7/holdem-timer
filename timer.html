<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 50px;
            background-color: black;
            color: white;
        }
        .container {
            display: flex;
            justify-content: space-between;
        }
        .column {
            width: 30%;
            padding: 20px;
        }
.column:first-child div {
    line-height: 0; /* 원하는 줄 간격으로 조정하세요 */
}
.column:nth-child(2) {
    text-align: center; /* 가운데 정렬 */
    width: 40%;
}
        button {
            margin: 5px;
            padding: 10px;
            background-color: #555;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #777;
        }
        #blindTimer {
            font-weight: 300;
            margin: 10px 0;
        }
        input[type="number"] {
            width: 60px;
            color: black;
        }
        .progress-container {
            width: 100%;
            height: 30px;
            background-color: #444;
            position: relative;
            margin: 10px 0;
        }
        .progress {
            height: 100%;
            background-color: #28a745;
            position: absolute;
            top: 0;
            left: 0;
        }
        .marker {
            width: 10px;
            height: 30px;
            background-color: #fff;
            position: absolute;
            top: 0;
            cursor: pointer;
        }
.next-level {
    font-size: 20px; /* 원하는 크기로 조정하세요 */
}
.next-level-title {
    font-size: 20px; /* 글자 크기를 20px로 설정 */
}
button {
    margin: 16px 7px; /* 위쪽 마진을 늘려서 간격을 조정하세요 */
}
#pauseOverlay {
    position: absolute;
    top: 150px; /* 블라인드 타이머의 위치에 맞게 조정하세요 */
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 0, 0, 0.5); /* 반투명 빨간색 */
    padding: 20px;
    border-radius: 10px;
    z-index: 10; /* 다른 요소 위에 표시되도록 설정 */
}

    </style>
</head>
<body>
    <div class="container">
        <div class="column">
            <h2>TOTAL TIME:</h2>
            <div id="totalTime" style="font-size: 20px;">00:00:00</div>
            <h2>TOTAL CHIPS:</h2>
            <div id="totalChips" style="margin-bottom: 15px;">0</div>
            <div id="totalChipsBB" style="font-size: 15px;">(0 BB)</div>
            <h2>AVR STACK:</h2>
            <div id="avrStack" style="margin-bottom: 15px;">0</div>
            <div id="avrStackBB" style="font-size: 15px;">(0 BB)</div>
            <h2>PLAYERS:</h2>
            <div id="players">0 / 0</div>
            <h2>NEXT BREAK:</h2>
            <div id="nextBreak" style="font-size: 20px;">00:00:00</div>
        </div>

<div id="pauseOverlay" style="display: none;">
    <div style="color: red; font-size: 50px; font-weight: bold;">PAUSE</div>
</div>

        <div class="column">
            <h2 id="currentLevel">Level 1</h2>
            <h2 id="blindTimer" style="font-size: 150px;">00:00</h2>
            <h2>BLINDS <span id="currentBlinds">0 / 0 / 0</span></h2>
            <h2 class="next-level-title">NEXT LV <span id="nextBlinds" class="next-level">0 / 0 / 0</span></h2>
            <div class="progress-container" id="progress">
                <div class="progress" id="progressBar"></div>
                <div class="marker" id="marker"></div>
            </div>
        </div>

        <div class="column">
            <button onclick="previousLevel()"><<</button>
            <button id="playPauseBtn" onclick="toggleTimer()">▶ / I I</button>
            <button onclick="nextLevel()">>></button>
            <br>
            <button onclick="increaseTimer(10)"><(10초)</button>
            <button onclick="decreaseTimer(10)">(10초)></button>
            <br>
<div>
    <label class="chip-option">
        <input type="radio" name="chipAmount" value="40000" checked> 40,000 chips
    </label>
    <br>
    <label class="chip-option">
        <input type="radio" name="chipAmount" value="45000"> 45,000 chips
    </label>
    <br>
    <label class="chip-option">
        <input type="radio" name="chipAmount" value="48000"> 48,000 chips
    </label>
    <br>
    <label class="chip-option">
        <input type="radio" name="chipAmount" value="50000"> 50,000 chips
    </label>
</div>
            <br>
<button onclick="increaseChipAmount()">+</button>
<button onclick="decreaseChipAmount()">-</button>
            <br>
            <button onclick="confirmHeadsUp()">Heads-up</button>
        </div>
    </div>

    <div id="confirmationModal" style="display:none; position:fixed; left:50%; top:50%; transform:translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); padding: 20px; z-index: 1000;">
        <p>실행하시겠습니까?</p>
        <button onclick="startHeadsUp()">확인</button>
        <button onclick="cancelHeadsUp()">취소</button>
    </div>

    <script>
    const levelChangeSound = new Audio('https://github.com/handream7/holdem-timer/raw/9ca20fd264c1a0af29b620d2c9e254beeb7c3d05/alarm.mp3');
    const breakSound = new Audio('https://github.com/handream7/holdem-timer/raw/9ca20fd264c1a0af29b620d2c9e254beeb7c3d05/alarm.mp3');

        let blinds = JSON.parse(localStorage.getItem('blinds'));
        let currentLevel = 0;
        let timerInterval;
        let totalTime = 0;
        let blindTime = 0; // 블라인드 타이머
        let totalTimeElapsed = 0; // 총 경과 시간
        let headsUpMode = false;

        // 칩 선택 함수
        function setChipAmount() {
            const selectedChip = document.querySelector('input[name="chipAmount"]:checked');
            if (selectedChip) {
                const chipAmount = selectedChip.value;
                // 여기에서 chipAmount를 사용하여 필요한 작업을 수행하세요
                alert(`선택한 칩: ${chipAmount}`);
            }
        }

function updateBlinds() {
    const current = blinds[currentLevel];
    
    // 블라인드 정보 업데이트
    document.getElementById('currentBlinds').innerText = 
        `${current.small.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')} / ${current.big.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')} / ${current.ante.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`;
    
    if (currentLevel < blinds.length - 1) {
        const next = blinds[currentLevel + 1];
        document.getElementById('nextBlinds').innerText = 
            `${next.small.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')} / ${next.big.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')} / ${next.ante.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`;
        document.getElementById('nextBlinds').insertAdjacentHTML('afterbegin', `${currentLevel + 2} `);
    } else {
        document.getElementById('nextBlinds').innerText = 'N/A';
    }

    document.getElementById('currentLevel').innerText = `LEVEL ${currentLevel + 1}`;
    blindTime = current.duration * 60; // 블라인드 타이머 초기화
    totalTime = 0; // 총 시간 초기화

    // TOTAL CHIPS를 현재 레벨의 빅 블라인드로 나누어 XX BB 계산
    const bigBlindValue = current.big; // 현재 레벨의 빅 블라인드
    const bbAmount = bigBlindValue > 0 ? Math.round((totalChips / bigBlindValue) * 10) / 10 : 0; // 소수점 둘째 자리에서 반올림
    document.getElementById('totalChipsBB').innerText = `(${bbAmount}BB)`; // BB 값 업데이트

    // AVR STACK BB 계산 (totalChipsBB 값 업데이트 후)
    const avrStackBB = playersX > 0 ? Math.round(bbAmount / playersX * 10) / 10 : 0; // AVR STACK BB 계산
    document.getElementById('avrStackBB').innerText = `(${avrStackBB}BB)`; // AVR STACK BB 값 업데이트

    updateTimers(); // 타이머 업데이트
}

        function updateNextBreakTimer() {
            let totalNextBreakTime = 0;

            const current = blinds[currentLevel];

            // 레벨 5, 10, 15, 20의 경우 해당 Level의 Duration 잔여 시간만 보여줌
            if ((currentLevel + 1) % 5 === 0) {
                totalNextBreakTime += blindTime; // 현재 레벨의 잔여 시간만 추가
            } else if (current.break > 0 && blindTime > 0) {
                // 현재 블라인드가 브레이크 타이머인 경우
                totalNextBreakTime += blindTime; // 현재 브레이크 잔여 시간 추가

                // 다음 브레이크까지의 레벨들의 Duration 합산
                for (let i = currentLevel + 1; i < blinds.length; i++) {
                    const nextLevel = blinds[i];
                    totalNextBreakTime += nextLevel.duration * 60; // 초로 변환
                    if (nextLevel.break > 0) {
                        break; // 다음 브레이크가 있는 레벨에서 종료
                    }
                }
            } else {
                // 현재 레벨의 남은 Duration과 다음 레벨들의 Duration 합산
                totalNextBreakTime += blindTime; // 현재 레벨의 남은 Duration
                for (let i = currentLevel + 1; i < blinds.length; i++) {
                    const nextLevel = blinds[i];
                    totalNextBreakTime += nextLevel.duration * 60; // 초로 변환
                    if (nextLevel.break > 0) {
                        break; // 브레이크 있는 레벨에서 종료
                    }
                }
            }

            // 타이머 업데이트
            document.getElementById('nextBreak').innerText = formatTotalTime(totalNextBreakTime);
        }

        function updateTimers() {
            document.getElementById('blindTimer').innerText = formatBlindTime(blindTime);
            document.getElementById('totalTime').innerText = formatTotalTime(totalTimeElapsed);
            updateNextBreakTimer(); // 다음 브레이크 타이머 업데이트
            updateProgressBar(blindTime);
        }

        function updateProgressBar(remainingTime) {
            const current = blinds[currentLevel];
            const totalDuration = current.duration * 60;
            const percentage = ((totalDuration - remainingTime) / totalDuration) * 100;
            const progressBar = document.getElementById('progressBar');
            const marker = document.getElementById('marker');
            progressBar.style.width = `${percentage}%`;
            marker.style.left = `${percentage}%`;
        }

        function formatBlindTime(seconds) {
            const minutes = String(Math.floor(seconds / 60)).padStart(2, '0');
            const secs = String(seconds % 60).padStart(2, '0');
            return `${minutes}:${secs}`;
        }

        function formatTotalTime(seconds) {
            const hours = String(Math.floor(seconds / 3600)).padStart(2, '0');
            const minutes = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
            const secs = String(seconds % 60).padStart(2, '0');
            return `${hours}:${minutes}:${secs}`;
        }

        function updateTimer() {
            if (blindTime > 0) {
                blindTime -= 1; // 블라인드 타이머 감소
            }
            totalTimeElapsed += 1; // 총 경과 시간 증가
            updateTimers();
            
            if (blindTime <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;
                handleBreak();
            }
        }

        function handleBreak() {
            const current = blinds[currentLevel];
            if (current.break > 0) {
                blindTime = current.break * 60; // 브레이크 시간을 초로 설정
                document.getElementById('currentLevel').innerText = "Break Time";
                breakSound.play(); // Break 시작 시 소리 재생
                updateTimers();
                timerInterval = setInterval(updateBreakTimer, 1000);
            } else {
                nextLevel();
            }
        }

        function updateBreakTimer() {
            if (blindTime > 0) {
                blindTime -= 1; // 브레이크 타이머 감소
            }
            totalTimeElapsed += 1; // 총 경과 시간 증가
            updateTimers();
            
            if (blindTime <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;
                nextLevel();
            }
        }

        function toggleTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            } else {
                timerInterval = setInterval(updateTimer, 1000);
            }
        }

        function previousLevel() {
            if (currentLevel > 0) {
                currentLevel--;
                updateBlinds();
            }
        }

        function nextLevel() {
            if (currentLevel < blinds.length - 1) {
                currentLevel++;
                updateBlinds();
            levelChangeSound.play(); // 레벨 변경 시 소리 재생
                startTimer();
            } else {
                alert("마지막 레벨입니다.");
            }
        }

        function startTimer() {
            blindTime = blinds[currentLevel].duration * 60; // 다음 레벨의 Duration을 초로 설정
            updateTimers();
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
        }

        function confirmHeadsUp() {
            document.getElementById('confirmationModal').style.display = 'block';
        }

let totalChips = 0; // 총 칩 수량
let playersX = 0; // 플레이어 수 X
let playersY = 0; // 플레이어 수 Y

function increaseChipAmount() {
    const selectedChip = document.querySelector('input[name="chipAmount"]:checked');
    if (selectedChip) {
        const chipAmount = parseInt(selectedChip.value, 10);
        totalChips += chipAmount; // 총 칩 수량 증가
        playersX += 1; // 플레이어 수 X 증가
        playersY += 1; // 플레이어 수 Y 증가
        updateDisplay(); // UI 업데이트
    }
}

function decreaseChipAmount() {
    if (playersX > 0) { // 플레이어 수 X가 0보다 클 때만 감소
        playersX -= 1; // 플레이어 수 X 감소
        updateDisplay(); // UI 업데이트
    }
}

function formatNumberWithCommas(number) {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function updateDisplay() {
    // TOTAL CHIPS 업데이트
    document.getElementById('totalChips').innerText = formatNumberWithCommas(totalChips);
    document.getElementById('players').innerText = `${playersX} / ${playersY}`; // PLAYERS 업데이트

    // AVR STACK 계산
    const avrStack = playersX > 0 ? Math.round(totalChips / playersX) : 0; // 플레이어 수 X가 0보다 클 때만 계산
    document.getElementById('avrStack').innerText = formatNumberWithCommas(avrStack); // AVR STACK 업데이트

    // TOTAL CHIPS를 빅 블라인드로 나누어 XX BB 계산
    const current = blinds[currentLevel]; // 현재 레벨의 블라인드 정보 가져오기
    const bigBlindValue = current.big; // 현재 레벨의 빅 블라인드
    const bbAmount = bigBlindValue > 0 ? Math.round((totalChips / bigBlindValue) * 10) / 10 : 0; // 소수점 둘째 자리에서 반올림
    document.getElementById('totalChipsBB').innerText = `(${bbAmount}BB)`; // BB 값 업데이트

    // AVR STACK BB 계산 (totalChipsBB 값이 바뀔 때마다 재계산)
    const avrStackBB = playersX > 0 ? Math.round(bbAmount / playersX * 10) / 10 : 0; // AVR STACK BB 계산
    document.getElementById('avrStackBB').innerText = `(${avrStackBB}BB)`; // AVR STACK BB 값 업데이트
}

function toggleTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
        document.getElementById('pauseOverlay').style.display = 'block'; // PAUSE 박스 표시
    } else {
        timerInterval = setInterval(updateTimer, 1000);
        document.getElementById('pauseOverlay').style.display = 'none'; // PAUSE 박스 숨기기
    }
}


function startHeadsUp() {
    headsUpMode = true;
    document.getElementById('confirmationModal').style.display = 'none';

    // 현재 레벨의 Duration은 유지하고, 다음 레벨부터 마지막 레벨까지의 Duration을 5분으로 설정
    for (let i = currentLevel + 1; i < blinds.length; i++) {
        blinds[i].duration = 5; // 다음 레벨의 duration을 5분으로 설정
    }

    updateNextBreakTimer(); // 다음 브레이크 타이머 업데이트
    updateTimers(); // UI 업데이트
}

        function cancelHeadsUp() {
            document.getElementById('confirmationModal').style.display = 'none';
        }

        function increaseTimer(seconds) {
            blindTime += seconds;
            updateTimers();
        }

        function decreaseTimer(seconds) {
            if (blindTime > seconds) {
                blindTime -= seconds;
                updateTimers();
            }
        }

        function setCustomTime() {
            const customTime = document.getElementById('customTime').value;
            blindTime = Math.round(parseInt(customTime, 10) / 1000); // 초로 변환 및 반올림
            updateTimers();
        }

        function handleMarkerDrag(event) {
            const progressContainer = document.getElementById('progress');
            const boundingBox = progressContainer.getBoundingClientRect();
            const offsetX = event.clientX - boundingBox.left;
            const percentage = Math.min(Math.max(offsetX / boundingBox.width, 0), 1) * 100;

            const current = blinds[currentLevel];
            const totalDuration = current.duration * 60;
            const newRemainingTime = Math.round(totalDuration * (1 - percentage / 100));

            document.getElementById('marker').style.left = `${percentage}%`;
            updateProgressBar(newRemainingTime);
            blindTime = newRemainingTime; // 블라인드 타이머 업데이트
        }

        function dragStart(event) {
            event.preventDefault();
            const handleMouseMove = (e) => handleMarkerDrag(e);
            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        document.getElementById('marker').addEventListener('mousedown', (event) => dragStart(event));

        updateBlinds();
    </script>
</body>
</html>

